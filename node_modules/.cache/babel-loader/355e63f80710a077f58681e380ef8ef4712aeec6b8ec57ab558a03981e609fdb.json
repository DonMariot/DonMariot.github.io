{"ast":null,"code":"import { useRef, useEffect } from 'react';\nimport Tweezer from 'tweezer.js';\nvar Direction;\n(function (Direction) {\n  Direction[Direction[\"Up\"] = 0] = \"Up\";\n  Direction[Direction[\"Down\"] = 1] = \"Down\";\n  Direction[Direction[\"None\"] = 2] = \"None\";\n})(Direction || (Direction = {}));\nconst INTERACTION_TIMEOUT = 150;\nfunction useScrollSnap({\n  ref: elementRef,\n  duration = 100,\n  isArrowKeysEnabled = true,\n  isDirectionEnabled = true\n}) {\n  const dataRef = useRef({\n    currentIndex: 0,\n    currentOffset: 0,\n    targetOffset: 0,\n    timeoutID: 0,\n    direction: Direction.None,\n    directionStart: 0,\n    animation: null\n  });\n  const getTargetScrollOffset = element => {\n    let top = element.offsetTop;\n    while (element.offsetParent) {\n      element = element.offsetParent;\n      top += element.offsetTop;\n    }\n    return top;\n  };\n  const getChildElements = () => {\n    if (elementRef.current && elementRef.current.children.length > 0) {\n      return Array.from(elementRef.current.children);\n    } else {\n      return [];\n    }\n  };\n  // Modified from https://stackoverflow.com/a/125106\n  const getElementsInView = () => {\n    return getChildElements().filter(element => {\n      const height = element.offsetHeight;\n      let top = element.offsetTop;\n      while (element.offsetParent) {\n        element = element.offsetParent;\n        top += element.offsetTop;\n      }\n      return top < window.scrollY + window.innerHeight && top + height > window.scrollY;\n    });\n  };\n  const getElementViewportHeight = element => {\n    const viewportHeight = window.innerHeight;\n    const rect = element.getBoundingClientRect();\n    let elementY;\n    if (rect.top < 0) {\n      elementY = rect.bottom;\n    } else if (rect.bottom > viewportHeight) {\n      elementY = viewportHeight - rect.top;\n    } else {\n      elementY = rect.bottom - rect.top;\n    }\n    return elementY;\n  };\n  const findSnapTarget = () => {\n    const elementsInView = getElementsInView();\n    if (elementsInView.length < 1) return;\n    dataRef.current.currentOffset = window.scrollY;\n    if (isDirectionEnabled) {\n      if (dataRef.current.direction === Direction.Up) {\n        snapToTarget(elementsInView[0]);\n        return;\n      } else if (dataRef.current.direction === Direction.Down) {\n        snapToTarget(elementsInView[elementsInView.length - 1]);\n        return;\n      }\n    }\n    let largestElement;\n    let largestHeight = -1;\n    for (const element of elementsInView) {\n      const elementHeight = getElementViewportHeight(element);\n      if (elementHeight > largestHeight) {\n        largestElement = element;\n        largestHeight = elementHeight;\n      }\n    }\n    if (largestElement) {\n      snapToTarget(largestElement);\n    }\n  };\n  const snapToTarget = target => {\n    if (dataRef.current.animation) {\n      dataRef.current.animation.stop();\n    }\n    const elements = getChildElements();\n    for (let i = 0; i < elements.length; ++i) {\n      const element = elements[i];\n      if (element.isSameNode(target)) {\n        dataRef.current.currentIndex = i;\n      }\n    }\n    dataRef.current.targetOffset = getTargetScrollOffset(target);\n    const animation = new Tweezer({\n      start: 0,\n      end: 10000,\n      duration: duration\n    });\n    animation.on('tick', tickAnimation);\n    animation.on('done', clearAnimation);\n    dataRef.current.animation = animation;\n    animation.begin();\n  };\n  const tickAnimation = value => {\n    const scrollTopDelta = dataRef.current.targetOffset - dataRef.current.currentOffset;\n    const scrollTop = dataRef.current.currentOffset + scrollTopDelta * value / 10000;\n    window.scrollTo({\n      top: scrollTop,\n      behavior: 'smooth'\n    });\n  };\n  const clearAnimation = () => {\n    clearTimeout(dataRef.current.timeoutID);\n    if (dataRef.current.animation) {\n      dataRef.current.animation.stop();\n    }\n    dataRef.current = {\n      currentIndex: dataRef.current.currentIndex,\n      currentOffset: 0,\n      targetOffset: 0,\n      timeoutID: 0,\n      direction: Direction.None,\n      directionStart: 0,\n      animation: null\n    };\n  };\n  const handleInteraction = () => {\n    dataRef.current.timeoutID = setTimeout(findSnapTarget, INTERACTION_TIMEOUT);\n  };\n  const handleWheel = event => {\n    clearAnimation();\n    if (event.deltaY < 0) {\n      dataRef.current.direction = Direction.Up;\n    } else if (event.deltaY > 0) {\n      dataRef.current.direction = Direction.Down;\n    } else {\n      dataRef.current.direction = Direction.None;\n    }\n    handleInteraction();\n  };\n  const handleTouchStart = event => {\n    dataRef.current.directionStart = event.touches[0].clientY;\n  };\n  const handleTouchMove = event => {\n    const deltaY = event.touches[0].clientY - dataRef.current.directionStart;\n    if (deltaY > 0) {\n      dataRef.current.direction = Direction.Up;\n    } else {\n      dataRef.current.direction = Direction.Down;\n    }\n    handleInteraction();\n  };\n  const handleKeyDown = event => {\n    const currentIndex = dataRef.current.currentIndex;\n    if (event.code === 'ArrowUp' && currentIndex > 0) {\n      event.preventDefault();\n      const elements = getChildElements();\n      const element = elements[currentIndex - 1];\n      clearAnimation();\n      snapToTarget(element);\n    } else if (event.code === 'ArrowDown') {\n      const elements = getChildElements();\n      if (currentIndex < elements.length - 1) {\n        event.preventDefault();\n        const element = elements[currentIndex + 1];\n        clearAnimation();\n        snapToTarget(element);\n      }\n    }\n  };\n  const goto = index => {\n    const elements = getChildElements();\n    const element = elements[index];\n    if (element) {\n      clearAnimation();\n      snapToTarget(element);\n    }\n  };\n  useEffect(() => {\n    clearAnimation();\n    document.addEventListener('wheel', handleWheel, {\n      passive: true\n    });\n    document.addEventListener('touchstart', handleTouchStart, {\n      passive: true\n    });\n    document.addEventListener('touchmove', handleTouchMove, {\n      passive: true\n    });\n    if (isArrowKeysEnabled) {\n      document.addEventListener('keydown', handleKeyDown);\n    }\n    findSnapTarget();\n    return () => {\n      clearAnimation();\n      document.removeEventListener('wheel', handleWheel);\n      document.removeEventListener('touchstart', handleTouchStart);\n      document.removeEventListener('touchmove', handleTouchMove);\n      if (isArrowKeysEnabled) {\n        document.removeEventListener('keydown', handleKeyDown);\n      }\n    };\n  }, []);\n  return {\n    state: dataRef,\n    goto\n  };\n}\nexport default useScrollSnap;","map":{"version":3,"names":["useRef","useEffect","Tweezer","Direction","INTERACTION_TIMEOUT","useScrollSnap","ref","elementRef","duration","isArrowKeysEnabled","isDirectionEnabled","dataRef","currentIndex","currentOffset","targetOffset","timeoutID","direction","None","directionStart","animation","getTargetScrollOffset","element","top","offsetTop","offsetParent","getChildElements","current","children","length","Array","from","getElementsInView","filter","height","offsetHeight","window","scrollY","innerHeight","getElementViewportHeight","viewportHeight","rect","getBoundingClientRect","elementY","bottom","findSnapTarget","elementsInView","Up","snapToTarget","Down","largestElement","largestHeight","elementHeight","target","stop","elements","i","isSameNode","start","end","on","tickAnimation","clearAnimation","begin","value","scrollTopDelta","scrollTop","scrollTo","behavior","clearTimeout","handleInteraction","setTimeout","handleWheel","event","deltaY","handleTouchStart","touches","clientY","handleTouchMove","handleKeyDown","code","preventDefault","goto","index","document","addEventListener","passive","removeEventListener","state"],"sources":["/home/dom/Documents/Documents/PROJETCS/Web/dom_site/client/node_modules/react-use-scroll-snap/dist/index.js"],"sourcesContent":["import { useRef, useEffect } from 'react';\nimport Tweezer from 'tweezer.js';\nvar Direction;\n(function (Direction) {\n    Direction[Direction[\"Up\"] = 0] = \"Up\";\n    Direction[Direction[\"Down\"] = 1] = \"Down\";\n    Direction[Direction[\"None\"] = 2] = \"None\";\n})(Direction || (Direction = {}));\nconst INTERACTION_TIMEOUT = 150;\nfunction useScrollSnap({ ref: elementRef, duration = 100, isArrowKeysEnabled = true, isDirectionEnabled = true, }) {\n    const dataRef = useRef({\n        currentIndex: 0,\n        currentOffset: 0,\n        targetOffset: 0,\n        timeoutID: 0,\n        direction: Direction.None,\n        directionStart: 0,\n        animation: null\n    });\n    const getTargetScrollOffset = (element) => {\n        let top = element.offsetTop;\n        while (element.offsetParent) {\n            element = element.offsetParent;\n            top += element.offsetTop;\n        }\n        return top;\n    };\n    const getChildElements = () => {\n        if (elementRef.current && elementRef.current.children.length > 0) {\n            return Array.from(elementRef.current.children);\n        }\n        else {\n            return [];\n        }\n    };\n    // Modified from https://stackoverflow.com/a/125106\n    const getElementsInView = () => {\n        return getChildElements().filter((element) => {\n            const height = element.offsetHeight;\n            let top = element.offsetTop;\n            while (element.offsetParent) {\n                element = element.offsetParent;\n                top += element.offsetTop;\n            }\n            return top < (window.scrollY + window.innerHeight) && (top + height) > window.scrollY;\n        });\n    };\n    const getElementViewportHeight = (element) => {\n        const viewportHeight = window.innerHeight;\n        const rect = element.getBoundingClientRect();\n        let elementY;\n        if (rect.top < 0) {\n            elementY = rect.bottom;\n        }\n        else if (rect.bottom > viewportHeight) {\n            elementY = viewportHeight - rect.top;\n        }\n        else {\n            elementY = rect.bottom - rect.top;\n        }\n        return elementY;\n    };\n    const findSnapTarget = () => {\n        const elementsInView = getElementsInView();\n        if (elementsInView.length < 1)\n            return;\n        dataRef.current.currentOffset = window.scrollY;\n        if (isDirectionEnabled) {\n            if (dataRef.current.direction === Direction.Up) {\n                snapToTarget(elementsInView[0]);\n                return;\n            }\n            else if (dataRef.current.direction === Direction.Down) {\n                snapToTarget(elementsInView[elementsInView.length - 1]);\n                return;\n            }\n        }\n        let largestElement;\n        let largestHeight = -1;\n        for (const element of elementsInView) {\n            const elementHeight = getElementViewportHeight(element);\n            if (elementHeight > largestHeight) {\n                largestElement = element;\n                largestHeight = elementHeight;\n            }\n        }\n        if (largestElement) {\n            snapToTarget(largestElement);\n        }\n    };\n    const snapToTarget = (target) => {\n        if (dataRef.current.animation) {\n            dataRef.current.animation.stop();\n        }\n        const elements = getChildElements();\n        for (let i = 0; i < elements.length; ++i) {\n            const element = elements[i];\n            if (element.isSameNode(target)) {\n                dataRef.current.currentIndex = i;\n            }\n        }\n        dataRef.current.targetOffset = getTargetScrollOffset(target);\n        const animation = new Tweezer({\n            start: 0,\n            end: 10000,\n            duration: duration,\n        });\n        animation.on('tick', tickAnimation);\n        animation.on('done', clearAnimation);\n        dataRef.current.animation = animation;\n        animation.begin();\n    };\n    const tickAnimation = (value) => {\n        const scrollTopDelta = dataRef.current.targetOffset - dataRef.current.currentOffset;\n        const scrollTop = dataRef.current.currentOffset + (scrollTopDelta * value / 10000);\n        window.scrollTo({ top: scrollTop, behavior: 'smooth' });\n    };\n    const clearAnimation = () => {\n        clearTimeout(dataRef.current.timeoutID);\n        if (dataRef.current.animation) {\n            dataRef.current.animation.stop();\n        }\n        dataRef.current = {\n            currentIndex: dataRef.current.currentIndex,\n            currentOffset: 0,\n            targetOffset: 0,\n            timeoutID: 0,\n            direction: Direction.None,\n            directionStart: 0,\n            animation: null,\n        };\n    };\n    const handleInteraction = () => {\n        dataRef.current.timeoutID = setTimeout(findSnapTarget, INTERACTION_TIMEOUT);\n    };\n    const handleWheel = (event) => {\n        clearAnimation();\n        if (event.deltaY < 0) {\n            dataRef.current.direction = Direction.Up;\n        }\n        else if (event.deltaY > 0) {\n            dataRef.current.direction = Direction.Down;\n        }\n        else {\n            dataRef.current.direction = Direction.None;\n        }\n        handleInteraction();\n    };\n    const handleTouchStart = (event) => {\n        dataRef.current.directionStart = event.touches[0].clientY;\n    };\n    const handleTouchMove = (event) => {\n        const deltaY = event.touches[0].clientY - dataRef.current.directionStart;\n        if (deltaY > 0) {\n            dataRef.current.direction = Direction.Up;\n        }\n        else {\n            dataRef.current.direction = Direction.Down;\n        }\n        handleInteraction();\n    };\n    const handleKeyDown = (event) => {\n        const currentIndex = dataRef.current.currentIndex;\n        if (event.code === 'ArrowUp' && currentIndex > 0) {\n            event.preventDefault();\n            const elements = getChildElements();\n            const element = elements[currentIndex - 1];\n            clearAnimation();\n            snapToTarget(element);\n        }\n        else if (event.code === 'ArrowDown') {\n            const elements = getChildElements();\n            if (currentIndex < elements.length - 1) {\n                event.preventDefault();\n                const element = elements[currentIndex + 1];\n                clearAnimation();\n                snapToTarget(element);\n            }\n        }\n    };\n    const goto = (index) => {\n        const elements = getChildElements();\n        const element = elements[index];\n        if (element) {\n            clearAnimation();\n            snapToTarget(element);\n        }\n    };\n    useEffect(() => {\n        clearAnimation();\n        document.addEventListener('wheel', handleWheel, { passive: true });\n        document.addEventListener('touchstart', handleTouchStart, { passive: true });\n        document.addEventListener('touchmove', handleTouchMove, { passive: true });\n        if (isArrowKeysEnabled) {\n            document.addEventListener('keydown', handleKeyDown);\n        }\n        findSnapTarget();\n        return () => {\n            clearAnimation();\n            document.removeEventListener('wheel', handleWheel);\n            document.removeEventListener('touchstart', handleTouchStart);\n            document.removeEventListener('touchmove', handleTouchMove);\n            if (isArrowKeysEnabled) {\n                document.removeEventListener('keydown', handleKeyDown);\n            }\n        };\n    }, []);\n    return {\n        state: dataRef,\n        goto\n    };\n}\nexport default useScrollSnap;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}